{
  "19_20-2-2-python": {
    "title_eng": "Stack (Python)",
    "description_eng": "The Reverse Polish Notation / Postfix Notation is a special notation for\nfor mathematical expressions, where the numbers are given first, followed by the\noperators. The expression (1 * 2)+(3 * 4) would be 1 2 * 3 4 * + in this notation.\n\nA calculator for this notation can be represented well with the help of a stack.\nThe notation is processed from left to right.\nIf a number is processed, it is put on the stack.\nIf an operator is encountered, then the uppermost two numbers are taken from the stack,\nthe operator is executed and the result is put back on the stack.\nAfter the calculation, the result is the only number on the stack.\n\nIn this task you are asked to implement such a calculator in a method.\nIt should be able to process the operators plus (+), minus (-), times (*)\nand division (/, rounded down). You will receive a stack with the following\nknown methods, which you have to use in your implementation:\n\n* emptystack()\n* head()\n* push(int i)\n* pop()\n\nThe method receives as input a list of strings in which the\nnumbers and operators are already separated (e.g..: input =\n[\"1\", \"2\", \"*\", \"3\", \"4\", \"*\", \"+\"]). Strings can be converted with \"int(myString)\".\nYou will also get a stack, which you should use.\nThe method should return the correct result as an integer.\n\nYou can assume that the input is a correct formula.\n",
    "skeleton_code": "def Calculator(inputarray, stack):\n    return 0",
    "reference_solution": "# This implementation assumes input is a correct formula\ndef Calculator(inputarray, stack):\n    for i in inputarray:\n        try:\n            stack.push({\n                \"+\": lambda x, y: y+x,\n                \"-\": lambda x, y: y-x,\n                \"*\": lambda x, y: y*x,\n                \"/\": lambda x, y: y/x,}[i](stack.pop(), stack.pop()))\n        except KeyError:\n            stack.push(int(i))\n    return stack.pop()"
  },
  "19_20-3-1-python": {
    "title_eng": "List Sorting (Python)",
    "description_eng": "Implement any search algorithm from the lecture\nthat sorts the given list.\n\nThe list has the following operations, which get as input indexes of the\nlist elements:\n\n* Swap(int x, int y) <- Swaps the items at position x and y.\n\n* Larger(int x, int y) <- Returns true if the item at\nposition x is greater than the item at position y\n\n* Smaller(int x, int y) <- Returns true if the item at\nposition y is greater than the element at position x\n\n* Equal(int x, int y) <- Returns true if the element at\nposition y is equal to the element at position x\n\n* Length() <- Returns the length of the list\n",
    "skeleton_code": "def listSorter(listToSort: ListToSort) -> ListToSort:\n    pass",
    "reference_solution": "def listSorter(listToSort: ListToSort) -> ListToSort:\n    \"\"\"\n    This is an implimentation of bubble sort\n    \"\"\"\n    changed = True\n    while changed:\n        changed = False\n        for i in range(1, listToSort.Length()):\n            if listToSort.Larger(i-1, i):\n                listToSort.Swap(i-1, i)\n                changed = True\n    return listToSort"
  },
  "19_20-5-1-python": {
    "title_eng": "Graphs: BFS (Python)",
    "description_eng": "This task is about the implementation of graphs and very\nsimple graph algorithms. In Java we implement graphs with the\nthe help of arrays. We look at graphs with unweighted edges.\nTo represent a graph in Java, we give all nodes a number (starting with 0),\nwhich corresponds to the index of the adjacency list in the list. Example:\n\ngraph = [\n    [1, 2],\n    [0],\n    [1]\n]\n\nEach of these edges can now be considered as directed, going out\nfrom the node with the index number to the node with the corresponding\nnumber (see image for a graphical visualization).\n\nNow we want to implement some simple algorithms for the graphs,\nstarting with breadth-first search. How this\nalgorithm works can be found in the lecture, see also Cormen et\nal, chap. 22. The inputs are assumed to be unweighted, directed graphs,\nso it is not always the case that for each edge there is also a back edge\nrunning in the opposite direction.\n\nThe outputs shall contain the nodes of the graph in the order\nas they are processed by the corresponding search.\nThe nodes are to be traversed in the order in which they are arranged in the adjacency list.",
    "skeleton_code": "def bfs(graph, start):\n    return []",
    "reference_solution": "def bfs(graph, start):\n    visited, queue = list(), [start]\n    while queue:\n        next = queue.pop(0)\n        if next not in visited:\n            visited.append(next)\n            for vertex in graph[next]:\n                if vertex not in visited:\n                    queue.append(vertex)\n    return visited"
  },
  "20_21-1-2-python": {
    "title_eng": "Sorting (Python)",
    "description_eng": "Input: An array $A = [a_1, a_2,...,a_n]$ with $2 \\leq n \\leq 10^6$\nand $\\forall 1\\leq i \\leq n: -10^6 \\leq a_i \\leq 10^6$\n\nOutput:  Array A sorted in ascending order: $A = [a_1, a_2,...,a_n]$,\nwhere $\\forall 1 \\leq i \\leq j \\leq n: \\; a[i] \\leq a[j]$\n\nImplement a sorting procedure in the function \"solution\", which takes\nas argument an array \"A\".  Your procedure should\neither have a worst-case run time of $O(n \\; log \\; n)$ or an\naverage-case run time of $O(n \\; log \\; n)$ (this should be guaranteed by\nrandomization). Your solution must not contain the string\n\"sort\" and \"numpy\" as substring. Importing the random\nlibrary is explicitly allowed!\n\nHint:\n\nMake absolutely sure that you randomize your algorithm using the\nPython Random Library. You can ignore this hint\nif your implementation has a worst-case runtime of $O(n \\; log \\; n)$.",
    "skeleton_code": "def solution(A):\n    pass",
    "reference_solution": "import random as rand\ndef randPartition(A,l,r):\n    i = rand.randint(l,r)\n    temp = A[i]\n    A[i] = A[r]\n    A[r] = temp\n    return partition(A,l,r)\n\ndef partition(A,l,r):\n    x = A[r]\n    i = l-1\n    for j in range(l,r):\n        if A[j] <= x:\n            i = i + 1\n            temp = A[i]\n            A[i] = A[j]\n            A[j] = temp\n    temp = A[i+1]\n    A[i+1] = A[r]\n    A[r] = temp\n    return i+1\n\ndef quick(A,l,r):\n    if l < r:\n        p = randPartition(A,l,r)\n        quick(A,l,p-1)\n        quick(A,p+1,r)\n\n\ndef solution(A):\n    quick(A,0,len(A)-1)\n    return A"
  },
  "20_21-3-1-python": {
    "title_eng": "Knapsack (Python) (revised version 2020/21)",
    "description_eng": "",
    "skeleton_code": "def knapSack(value, volume, capacity):\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    # TODO\n\n    return 0",
    "reference_solution": "def knapSack(value, volume, capacity):\n    \"\"\"This function calculates and returns the max\n    value in knapsack with the capacity \"capacity\" wich is filled\n    with stuff of volume \"volume\" and the value \"value\".\"\"\"\n\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    n = len(value)\n\n    Result = [0] * (n+1)\n    for i in range(n+1):\n        Result[i] = [0] * (capacity + 1)\n\n    for i in range(n+1):\n        for j in range(capacity + 1):\n            Result[i][j] = 0\n\n    for i in range(n-1,-1,-1):\n        for j in range(1, capacity + 1):\n            if volume[i] <= j:\n                Result[i][j] = max(value[i] + Result[i + 1][j - volume[i]],\n                                   Result[i+1][j])\n            else:\n                Result[i][j] = Result[i+1][j]\n\n    return Result[0][capacity]"
  },
  "20_21-3-2-python": {
    "title_eng": "Longest path DAG (Python)",
    "description_eng": "Input: A natural number $1 \\leq N \\leq 2500$, which indicates how many\nvertices the graph $G$ has, and a two-dimensional array $A$ of size\nsize $1 \\leq M \\leq 10^6$ of integers\n$A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]$ which is\nencodes the set of edges of $G$.  If $[a,b] \\in A$, then there is a\ndirected edge from the vertex $a$ to the vertex $b$. You may assume\nthat there are no directed cycles in $G$. For example: Let $N = 3$\nand $A = [[1,2],[2,3]]$ then the following graph is obtained:\n\n[]\n\nOutput: The length of the longest directed path in $G$.\nYour algorithm has to compute the solution in $O(N+M)$.\n\nTime limit: 1 CPU second\n\nHint:\n\n(1) The libraries java.util.Arrays, java.util.ArrayList, java.lang.Math\nare already imported automatically.\n\n(2) If you have difficulties with this task: Ignore\nthe runtime restrictions and first implement a naive \nrecursive solution. Then use dynamic programming\n(memoization) to achieve the desired runtime.\n\n(3) Some test cases have been hidden and are not displayed to\nprevent hardcoding of the solutions.",
    "skeleton_code": "def calc(N,A):\n    pass",
    "reference_solution": "def dfs(node, graph, memo):\n    if len(graph[node]) == 0:\n        return 0\n    elif memo[node] != -1:\n        return memo[node]\n    else:\n        sol = 0\n        for child in graph[node]:\n            sol = max(sol, dfs(child, graph, memo) + 1)\n        memo[node] = sol\n        return memo[node]\n\n\ndef calc(N, A):\n    graph = [[] for _ in range(N + 1)]\n    memo = [-1] * (N + 1)\n    graph[0] = [x for x in range(1, N + 1)]\n    for edge in A:\n        start, end = edge\n        graph[start].append(end)\n    return dfs(0, graph, memo) - 1"
  }
}
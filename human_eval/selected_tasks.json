{
    "19_20-1-1-python": {
      "title_eng": "LCM -- Least Common Multiple (Python)",
      "description_eng": "Similar to the already known \"Greatest Common Divisor\" (GCD),\nthe Least Common Multiple (LCM) is also used in elementary mathematical\napplications, for example in the multiplication of heterogeneous fractions. This\nhas applications ranging from the adaptation of cooking recipes to other\nportion quantities to the calculation of planetary orbits.\n\nThe LCM is defined as follows:\n$lcm(n_1, n_2)=\\frac{n_1 \\cdot n_2}{gcd(n_1,n_2)}$.\n\nImplement a function that calculates the LCM of two given values.\nIt may be based on the GCD implementation from the lecture.\n\nNote: The use of \"import\" is not allowed.",
      "skeleton_code": "def LCM(a, b):\n    pass",
      "reference_solution": "def GCD(a, b):\n    if a < b:\n        a, b = b, a\n    r = a % b\n    if r is 0:\n        return b\n    else:\n        return GCD(r, b)\n        \ndef LCM(a, b):\n    return a * b / GCD(a, b)"
    },
    "19_20-2-1-python": {
      "title_eng": "Queue (Python)",
      "description_eng": "Implement a class \"Queue\" that works like a queue (as described in the\nthe lecture). The class should have at least the\nmethods isEmpty(), head(), enqueue(x) and dequeue(). The\nqueue does not need to hold more than 100 elements.\n\nNote 1: In the Java test, the stack is expected to store \"strings\".\nSince Python is dynamically typed, this does not apply.\n\nNote 2: It is not allowed to use \"import\"!",
      "skeleton_code": "class Queue:\n    \"\"\"Klasse, die eine selbstgebaute Queue darstellt.\n    \"\"\"\n\n    def isEmpty(self):\n        \"\"\"Prueft, ob die Queue leer ist.\n        :return: True, wenn die Queue leer ist;\n            False, sonst\n        \"\"\"\n        pass\n\n    def head(self):\n        \"\"\"Gibt den Wert des ersten Elements in der Queue\n            zurueck.\n        :return: Den Wert des ersten Elementes in der Queue\n        \"\"\"\n        pass\n\n    def enqueue(self, x):\n        \"\"\"Haengt ein Element an die Queue an.\n        :param x: Anzuhaengendes Element\n        \"\"\"\n        pass\n\n    def dequeue(self):\n        \"\"\"Entfernt das erste Element aus der Queue\n        :return: Erstes Element\n        \"\"\"\n        pass",
      "reference_solution": "class Queue:\n    \"\"\"Klasse, die eine selbstgebaute Queue darstellt.\n    \"\"\"\n    def __init__(self):\n        self.lst = []\n\n    def isEmpty(self) -> bool:\n        \"\"\"Prueft, ob die Queue leer ist.\n        :return: True, wenn die Queue leer ist;\n            False, sonst\n        \"\"\"\n        return len(self.lst) == 0\n\n    def head(self):\n        \"\"\"Gibt den Wert des ersten Elements in der Queue\n            zurueck.\n        :return: Den Wert des ersten Elementes in der Queue\n        \"\"\"\n        if not self.isEmpty():\n            return self.lst[0]\n        else:\n            return None\n\n    def enqueue(self, x):\n        \"\"\"Haengt ein Element an die Queue an.\n        :param x: Anzuhaengendes Element\n        \"\"\"\n        self.lst.append(x)\n\n    def dequeue(self):\n        \"\"\"Entfernt das erste Element aus der Queue\n        :return: Erstes Element\n        \"\"\"\n        if not self.isEmpty():\n            returnvalue = self.lst[0]\n            for i in range(len(self.lst) - 1):\n                self.lst[i] = self.lst[i+1]\n            del self.lst[-1]\n            return returnvalue\n        else:\n            raise IndexError"
    },
    "19_20-2-2-python": {
      "title_eng": "Stack (Python)",
      "description_eng": "The Reverse Polish Notation / Postfix Notation is a special notation for\nfor mathematical expressions, where the numbers are given first, followed by the\noperators. The expression (1 * 2)+(3 * 4) would be 1 2 * 3 4 * + in this notation.\n\nA calculator for this notation can be represented well with the help of a stack.\nThe notation is processed from left to right.\nIf a number is processed, it is put on the stack.\nIf an operator is encountered, then the uppermost two numbers are taken from the stack,\nthe operator is executed and the result is put back on the stack.\nAfter the calculation, the result is the only number on the stack.\n\nIn this task you are asked to implement such a calculator in a method.\nIt should be able to process the operators plus (+), minus (-), times (*)\nand division (/, rounded down). You will receive a stack with the following\nknown methods, which you have to use in your implementation:\n\n* emptystack()\n* head()\n* push(int i)\n* pop()\n\nThe method receives as input a list of strings in which the\nnumbers and operators are already separated (e.g..: input =\n[\"1\", \"2\", \"*\", \"3\", \"4\", \"*\", \"+\"]). Strings can be converted with \"int(myString)\".\nYou will also get a stack, which you should use.\nThe method should return the correct result as an integer.\n\nYou can assume that the input is a correct formula.\n",
      "skeleton_code": "def Calculator(inputarray, stack):\n    return 0",
      "reference_solution": "# This implementation assumes input is a correct formula\ndef Calculator(inputarray, stack):\n    for i in inputarray:\n        try:\n            stack.push({\n                \"+\": lambda x, y: y+x,\n                \"-\": lambda x, y: y-x,\n                \"*\": lambda x, y: y*x,\n                \"/\": lambda x, y: y/x,}[i](stack.pop(), stack.pop()))\n        except KeyError:\n            stack.push(int(i))\n    return stack.pop()"
    },
    "19_20-3-1-python": {
      "title_eng": "List Sorting (Python)",
      "description_eng": "Implement any search algorithm from the lecture\nthat sorts the given list.\n\nThe list has the following operations, which get as input indexes of the\nlist elements:\n\n* Swap(int x, int y) <- Swaps the items at position x and y.\n\n* Larger(int x, int y) <- Returns true if the item at\nposition x is greater than the item at position y\n\n* Smaller(int x, int y) <- Returns true if the item at\nposition y is greater than the element at position x\n\n* Equal(int x, int y) <- Returns true if the element at\nposition y is equal to the element at position x\n\n* Length() <- Returns the length of the list\n",
      "skeleton_code": "def listSorter(listToSort: ListToSort) -> ListToSort:\n    pass",
      "reference_solution": "def listSorter(listToSort: ListToSort) -> ListToSort:\n    \"\"\"\n    This is an implimentation of bubble sort\n    \"\"\"\n    changed = True\n    while changed:\n        changed = False\n        for i in range(1, listToSort.Length()):\n            if listToSort.Larger(i-1, i):\n                listToSort.Swap(i-1, i)\n                changed = True\n    return listToSort"
    },
    "19_20-4-1-python": {
      "title_eng": "Search trees: Insertion (Python)",
      "description_eng": "These tasks will be about search trees. Our search trees are built from\n\"nodes\", analogous to the lecture. A node looks like this:\n\nclass Node:\n\u00a0* key\n\u00a0* left\n\u00a0* right\n\u00a0* parent\n\nIn the lecture you have already seen an algorithm for searching in a search tree.\n\nYou are to implement different methods for the search trees.\nFor this task, implement a method \"insert\" that inserts a\n\"Node\" into the search tree and returns the new search tree.\nThe nodes can be reused as desired. The function\nis passed the root of the search tree and the new node.",
      "skeleton_code": "# Node in parameter represents root of tree\ndef insert(root, insert):\n    return None",
      "reference_solution": "# Node in parameter represents root of tree\ndef insert(root: Node, insert: Node):\n    x = root\n    y = None  # saves Node.parent\n    while x is not None:\n        y = x\n        if insert.key < x.key:\n            x = x.left\n        else:\n            x = x.right;\n\n    insert.parent = y\n    if y is None:\n        return insert\n    elif insert.key < y.key:\n        y.left = insert\n    else:\n        y.right = insert;\n\n    return root"
    },
    "19_20-4-2-python": {
      "title_eng": "Search trees: Removal (Python)",
      "description_eng": "These tasks will again be about search trees. Reminder:\nOur search trees are built from \"nodes\", analogous to the lecture.\nA node looks like this:\n\nclass Node:\n\u00a0* key\n\u00a0* left\n\u00a0* right\n\u00a0* Parent\n\nFor this task, implement a method \"delete\" which deletes a\n\"Node\" in the search tree and returns the new search tree. Use the\nthe method from the lecture slides, i.e. the one with \"TREE-MINIMUM\".\nThe nodes can be reused as desired. The function gets the root\nof the search tree and the node to be deleted.\n",
      "skeleton_code": "# Node in parameter represents root of tree\ndef delete(root, delete):\n    return None",
      "reference_solution": "# Helper function\ndef tree_minimum(n):\n    while n.left is not None:\n        n = n.left\n    return n\n# Node in parameter represents root of tree\ndef delete(root: Node, delete: Node):\n    y = None  # y: node to delete (after swap)\n    if delete.left is None or delete.right is None:\n        y = delete\n    else:\n        y = tree_minimum(delete.right)\n    x = None  # non-null child of y\n    if y.left is not None:\n        x = y.left\n    else:\n        x = y.right\n    # now delete y\n    if x is not None:\n        x.parent = y.parent\n    if y.parent is None:\n        root = x\n    else:\n        if y is y.parent.left:\n            y.parent.left = x\n        else:\n            y.parent.right = x\n    # Copy data\n    if y is not delete:\n        delete.key = y.key\n    # y should have no reference and should be deleted by the python gc\n    return root"
    },
    "19_20-5-1-python": {
      "title_eng": "Graphs: BFS (Python)",
      "description_eng": "This task is about the implementation of graphs and very\nsimple graph algorithms. In Java we implement graphs with the\nthe help of arrays. We look at graphs with unweighted edges.\nTo represent a graph in Java, we give all nodes a number (starting with 0),\nwhich corresponds to the index of the adjacency list in the list. Example:\n\ngraph = [\n    [1, 2],\n    [0],\n    [1]\n]\n\nEach of these edges can now be considered as directed, going out\nfrom the node with the index number to the node with the corresponding\nnumber (see image for a graphical visualization).\n\nNow we want to implement some simple algorithms for the graphs,\nstarting with breadth-first search. How this\nalgorithm works can be found in the lecture, see also Cormen et\nal, chap. 22. The inputs are assumed to be unweighted, directed graphs,\nso it is not always the case that for each edge there is also a back edge\nrunning in the opposite direction.\n\nThe outputs shall contain the nodes of the graph in the order\nas they are processed by the corresponding search.\nThe nodes are to be traversed in the order in which they are arranged in the adjacency list.",
      "skeleton_code": "def bfs(graph, start):\n    return []",
      "reference_solution": "def bfs(graph, start):\n    visited, queue = list(), [start]\n    while queue:\n        next = queue.pop(0)\n        if next not in visited:\n            visited.append(next)\n            for vertex in graph[next]:\n                if vertex not in visited:\n                    queue.append(vertex)\n    return visited"
    },
    "19_20-5-2-python": {
      "title_eng": "Graphs: DFS (Python)",
      "description_eng": "As a second algorithm - analogous to the first task - a depth\ndepth-first search is to be implemented.\n\nHere, too, the nodes are to be visited in the order in which they appear in the adjacency list.",
      "skeleton_code": "def dfs(graph, start):\n    return []",
      "reference_solution": "def dfs(graph, start):\n    visited, queue = list(), [start]\n    while queue:\n        next = queue.pop()\n        if next not in visited:\n            visited.append(next)\n            for vertex in reversed(graph[next]): # Need to reverse list in order to visit vertex in correct order\n                if vertex not in visited:\n                    queue.append(vertex)\n    return visited"
    },
    "19_20-6-1-python": {
      "title_eng": "Dynamic Programming: Edit Distance (Python)",
      "description_eng": "In this task the edit distance of two given strings is implemented.\nThis is defined as the minimum number of insert, delete and replace operations\nof single characters to convert the one string into the other.\nImportant: The implementation must NOT use recursive calls.",
      "skeleton_code": "def editDistance(a, b):\n    return 0",
      "reference_solution": "def editDistance(a, b):\n    \"\"\"This function calculates and returns the edit distance\n    beween tow given strings. this strings are given by the\n    parameters a and b. In the implementation the recursive\n    definition is implemented iterativly\"\"\"\n    \n    m = len(a)\n    n = len(b)\n\n    edDis = [0] * (m+1)\n    for i in range(m+1):\n        edDis[i] = [0] * (n+1)\n\n    for i in range(m+1):\n        edDis[i][0] = i\n        \n    for i in range(n+1):\n        edDis[0][i] = i\n\n    for i in range(1,m+1):\n        for j in range(1,n+1):\n            if a[i-1]==b[j-1]:\n                edDis[i][j] = edDis[i-1][j-1]\n            else:\n                edDis[i][j] = 1 + min(edDis[i][j-1],\n                                      edDis[i-1][j],\n                                      edDis[i-1][j-1])\n\n    return edDis[len(a)][len(b)]"
    },
    "20_21-1-1-python": {
      "title_eng": "Exponentiation by squaring (Python)",
      "description_eng": "Input: $a,b,c \\in \\mathbb{N}_0  \\land 1 \\leq a \\leq 100 \\land 0 \\leq b \\leq 10^9 \\land 1 \\leq c \\leq 10^{10}$\n\nOutput: $a^b \\; mod \\; c$\n\nLet $a^b \\; mod \\; c$ be calculated in the function expo(a,b,c). Make sure\nthat your algorithm has a run time of $O(log \\; b + log \\; c)$.\nYour solution must not contain the string \"import\" and \"**\" as a\nsubstring. For easier debugging, you can divide your result\nin each calculation step by modulo $c$. For example (The example\ncan also be found commented out in the answer field):\n\ndef add(a,b,c,d,e):\n    res = (a+b) % 10000007\n    res = (res+c) % 10000007\n    res = (res+d) % 10000007\n    res = (res+e) % 10000007\n    return (res+1000) % 10000007\n\nHint:\n\nUse \"//\" (without the quotes) to perform integer division in\nPython and to avoid floats.\n\nIf $b$ is even, then:\n\n$a^b = (a^{\\frac{b}{2}})^2 = a^{\\frac{b}{2}} \\cdot a^{\\frac{b}{2}}$\n\nIf $b$ is odd, then:\n\n$a^b = a^{b-1} \\cdot a$",
      "skeleton_code": "def expo(a,b,c):\n    pass\n\n\n'''\ndef addiere(a,b,c,d,e):\n\n    res = (a+b) % 1000000007\n\n    res = (res+c) % 1000000007\n\n    res = (res+d) % 1000000007\n\n    res = (res+e) % 1000000007\n\n    return (res+1000) % 1000000007\n'''",
      "reference_solution": "def expo(a,b,c):\n    if b == 0:\n        return 1 % c\n    elif b % 2:\n        return (a * expo(a,b-1,c)) % c\n    else:\n        a = expo(a,b // 2,c) % c\n        return (a*a) % c"
    },
    "20_21-1-2-python": {
      "title_eng": "Sorting (Python)",
      "description_eng": "Input: An array $A = [a_1, a_2,...,a_n]$ with $2 \\leq n \\leq 10^6$\nand $\\forall 1\\leq i \\leq n: -10^6 \\leq a_i \\leq 10^6$\n\nOutput:  Array A sorted in ascending order: $A = [a_1, a_2,...,a_n]$,\nwhere $\\forall 1 \\leq i \\leq j \\leq n: \\; a[i] \\leq a[j]$\n\nImplement a sorting procedure in the function \"solution\", which takes\nas argument an array \"A\".  Your procedure should\neither have a worst-case run time of $O(n \\; log \\; n)$ or an\naverage-case run time of $O(n \\; log \\; n)$ (this should be guaranteed by\nrandomization). Your solution must not contain the string\n\"sort\" and \"numpy\" as substring. Importing the random\nlibrary is explicitly allowed!\n\nHint:\n\nMake absolutely sure that you randomize your algorithm using the\nPython Random Library. You can ignore this hint\nif your implementation has a worst-case runtime of $O(n \\; log \\; n)$.",
      "skeleton_code": "def solution(A):\n    pass",
      "reference_solution": "import random as rand\ndef randPartition(A,l,r):\n    i = rand.randint(l,r)\n    temp = A[i]\n    A[i] = A[r]\n    A[r] = temp\n    return partition(A,l,r)\n\ndef partition(A,l,r):\n    x = A[r]\n    i = l-1\n    for j in range(l,r):\n        if A[j] <= x:\n            i = i + 1\n            temp = A[i]\n            A[i] = A[j]\n            A[j] = temp\n    temp = A[i+1]\n    A[i+1] = A[r]\n    A[r] = temp\n    return i+1\n\ndef quick(A,l,r):\n    if l < r:\n        p = randPartition(A,l,r)\n        quick(A,l,p-1)\n        quick(A,p+1,r)\n\n\ndef solution(A):\n    quick(A,0,len(A)-1)\n    return A"
    },
    "20_21-3-1-python": {
      "title_eng": "Knapsack (Python) (revised version 2020/21)",
      "description_eng": "",
      "skeleton_code": "def knapSack(value, volume, capacity):\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    # TODO\n\n    return 0",
      "reference_solution": "def knapSack(value, volume, capacity):\n    \"\"\"This function calculates and returns the max\n    value in knapsack with the capacity \"capacity\" wich is filled\n    with stuff of volume \"volume\" and the value \"value\".\"\"\"\n\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    n = len(value)\n\n    Result = [0] * (n+1)\n    for i in range(n+1):\n        Result[i] = [0] * (capacity + 1)\n\n    for i in range(n+1):\n        for j in range(capacity + 1):\n            Result[i][j] = 0\n\n    for i in range(n-1,-1,-1):\n        for j in range(1, capacity + 1):\n            if volume[i] <= j:\n                Result[i][j] = max(value[i] + Result[i + 1][j - volume[i]],\n                                   Result[i+1][j])\n            else:\n                Result[i][j] = Result[i+1][j]\n\n    return Result[0][capacity]"
    },
    "20_21-3-2-python": {
      "title_eng": "Longest path DAG (Python)",
      "description_eng": "Input: A natural number $1 \\leq N \\leq 2500$, which indicates how many\nvertices the graph $G$ has, and a two-dimensional array $A$ of size\nsize $1 \\leq M \\leq 10^6$ of integers\n$A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]$ which is\nencodes the set of edges of $G$.  If $[a,b] \\in A$, then there is a\ndirected edge from the vertex $a$ to the vertex $b$. You may assume\nthat there are no directed cycles in $G$. For example: Let $N = 3$\nand $A = [[1,2],[2,3]]$ then the following graph is obtained:\n\n[]\n\nOutput: The length of the longest directed path in $G$.\nYour algorithm has to compute the solution in $O(N+M)$.\n\nTime limit: 1 CPU second\n\nHint:\n\n(1) The libraries java.util.Arrays, java.util.ArrayList, java.lang.Math\nare already imported automatically.\n\n(2) If you have difficulties with this task: Ignore\nthe runtime restrictions and first implement a naive \nrecursive solution. Then use dynamic programming\n(memoization) to achieve the desired runtime.\n\n(3) Some test cases have been hidden and are not displayed to\nprevent hardcoding of the solutions.",
      "skeleton_code": "def calc(N,A):\n    pass",
      "reference_solution": "def dfs(node, graph, memo):\n    if len(graph[node]) == 0:\n        return 0\n    elif memo[node] != -1:\n        return memo[node]\n    else:\n        sol = 0\n        for child in graph[node]:\n            sol = max(sol, dfs(child, graph, memo) + 1)\n        memo[node] = sol\n        return memo[node]\n\n\ndef calc(N, A):\n    graph = [[] for _ in range(N + 1)]\n    memo = [-1] * (N + 1)\n    graph[0] = [x for x in range(1, N + 1)]\n    for edge in A:\n        start, end = edge\n        graph[start].append(end)\n    return dfs(0, graph, memo) - 1"
    },
    "21_22-1-1-python": {
      "title_eng": "Divide and Conquer Recurrence [Python]",
      "description_eng": "Input: $n_0 \\in \\mathbb{N}_0: \\; 0 \\leq n_0 \\leq 10^{9}$ \n\nOutput: $a_{n_0} \\; mod \\; 10^9+7$ with\n$a_{n+1}=2 a_{n}+1 \\; \\; n \\in \\mathbb{N}_0, a_{0}=0$\n\nCalculate in $O(\\: log \\: n)$ the output for any input\nin the function \"def calc(n):\" that takes only an integer as a parameter.\nFor the implementation you must not use the keyword\n\"import\", \"**\", \"eval\" , \"checkCalc\", \"globals\", \"pow\" or \"expo\".\n\nFor easier debugging, you can divide your result in each calculation step by modulo $10^9+7$. For example:\n\ndef calc(a,b,c):\n\n    res = (a+b) % 10000007\n\n    res = (res+c) % 10000007\n\n    return (res+1000) % 10000007\n\nHints:\n\n1. Find a closed form for the recurrence.\n\n2. Use \"//\" (without the quotation marks) to perform integer division in\nPython and to avoid floats.\n\n3. If $b$ is even, then:\n\n$a^b = (a^{\\frac{b}{2}})^2 = a^{\\frac{b}{2}} \\cdot a^{\\frac{b}{2}}$\n\nIf $b$ is odd, then:\n\n$a^b = a^{b-1} \\cdot a$  \n",
      "skeleton_code": "def calc(n):\n    pass",
      "reference_solution": "def calc(n):\n    a = 2; b = n; c = 1000000007\n    return expo(a,b,c) - 1\ndef expo(a,b,c):\n    if b == 0:\n        return 1 % c\n    elif b % 2:\n        return (a * expo(a,b-1,c)) % c\n    else:\n        a = expo(a,b // 2,c) % c\n        return (a*a) % c"
    },
    "21_22-3-1-python": {
      "title_eng": "Billboard (Python)",
      "description_eng": "(This task is a slightly modified old exam task from the\nWS 2020/21)\n\nA company obtains permission to place billboards on one side of a road.\nAlong the $n \\in \\mathbb{N}$ kilometers long road, there are $n+1$ suitable\nlocations at intervals of exactly one kilometer. For the location at kilometer\n$i \\in\\{0,1, \\ldots, n\\}$ advertisers are willing to pay an amount $w_i$\nwith $0 < w_{i} < 10^9$ to the company. However, the road traffic regulation states\nthat there must be at least two kilometers between every two billboards.\nSo if the company places a billboard at kilometer $i$, then at kilometer $i-1$ and $i+1$\nno billboard may be placed.\n\nHelp the company determine a selection of locations that will\nmaximizes the total profit from renting the sites.\n\nInput: an array $W$ of size $n+1$ for a\n$n \\in \\mathbb{N} \\land 1 \\leq n \\leq 1000$.\n\nOutput: The maximum profit that can be obtained from the billboards.\n\nThe output must be calculated in $O(n)$.\n",
      "skeleton_code": "def opt(W):\n    pass",
      "reference_solution": "def opt(W):\n    n = len(W) - 1\n    memo = [-1] * (n + 1)\n    return opt_helper(n, W, memo)\n\n\ndef opt_helper(n, W, memo):\n    if n == 0:\n        return W[0]\n    if n == 1:\n        return max(W[0], W[1])\n    if memo[n] != -1:\n        return memo[n]\n    else:\n        memo[n] = max(W[n] + opt_helper(n - 2, W, memo), opt_helper(n - 1, W, memo))\n        return memo[n]"
    }
  }
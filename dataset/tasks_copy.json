{
  "19_20-1-1-python": {
    "title_eng": "LCM -- Least Common Multiple (Python)",
    "description_eng": "Similar to the already known \"Greatest Common Divisor\" (GCD),\nthe Least Common Multiple (LCM) is also used in elementary mathematical\napplications, for example in the multiplication of heterogeneous fractions. This has applications ranging from the adaptation of cooking recipes to other\nportion quantities to the calculation of planetary orbits.\n\nThe LCM is defined as follows:\n$lcm(n_1, n_2)=\\frac{n_1 \\cdot n_2}{gcd(n_1,n_2)}$.\n\nImplement a function that calculates the LCM of two given values.\nIt may be based on the GCD implementation from the lecture.\n\nNote: The use of \"import\" is not allowed.",
    "skeleton": "def LCM(a, b):\n    pass",
    "reference_solution": "def GCD(a, b):\n    if a < b:\n        a, b = b, a\n    r = a % b\n    if r is 0:\n        return b\n    else:\n        return GCD(r, b)\n        \ndef LCM(a, b):\n    return a * b / GCD(a, b)"
  },
  "19_20-2-1-python": {
    "title_eng": "Queue (Python)",
    "description_eng": "Implement a class \"Queue\" that works like a queue (as described in the\nthe lecture). The class should have at least the\nmethods isEmpty(), head(), enqueue(x) and dequeue(). The\nqueue does not need to hold more than 100 elements.\n\nNote 1: In the Java test, the stack is expected to store \"strings\".\nSince Python is dynamically typed, this does not apply.\n\nNote 2: It is not allowed to use \"import\"!",
    "skeleton": "class Queue:\n    \"\"\"Klasse, die eine selbstgebaute Queue darstellt.\n    \"\"\"\n\n    def isEmpty(self):\n        \"\"\"Prueft, ob die Queue leer ist.\n        :return: True, wenn die Queue leer ist;\n            False, sonst\n        \"\"\"\n        pass\n\n    def head(self):\n        \"\"\"Gibt den Wert des ersten Elements in der Queue\n            zurueck.\n        :return: Den Wert des ersten Elementes in der Queue\n        \"\"\"\n        pass\n\n    def enqueue(self, x):\n        \"\"\"Haengt ein Element an die Queue an.\n        :param x: Anzuhaengendes Element\n        \"\"\"\n        pass\n\n    def dequeue(self):\n        \"\"\"Entfernt das erste Element aus der Queue\n        :return: Erstes Element\n        \"\"\"\n        pass",
    "reference_solution": "class Queue:\n    \"\"\"Klasse, die eine selbstgebaute Queue darstellt.\n    \"\"\"\n    def __init__(self):\n        self.lst = []\n\n    def isEmpty(self) -> bool:\n        \"\"\"Prueft, ob die Queue leer ist.\n        :return: True, wenn die Queue leer ist;\n            False, sonst\n        \"\"\"\n        return len(self.lst) == 0\n\n    def head(self):\n        \"\"\"Gibt den Wert des ersten Elements in der Queue\n            zurueck.\n        :return: Den Wert des ersten Elementes in der Queue\n        \"\"\"\n        if not self.isEmpty():\n            return self.lst[0]\n        else:\n            return None\n\n    def enqueue(self, x):\n        \"\"\"Haengt ein Element an die Queue an.\n        :param x: Anzuhaengendes Element\n        \"\"\"\n        self.lst.append(x)\n\n    def dequeue(self):\n        \"\"\"Entfernt das erste Element aus der Queue\n        :return: Erstes Element\n        \"\"\"\n        if not self.isEmpty():\n            returnvalue = self.lst[0]\n            for i in range(len(self.lst) - 1):\n                self.lst[i] = self.lst[i+1]\n            del self.lst[-1]\n            return returnvalue\n        else:\n            raise IndexError"
  },
  "19_20-2-2-python": {
    "title_eng": "Stack (Python)",
    "description_eng": "The Reverse Polish Notation / Postfix Notation is a special notation for\nfor mathematical expressions, where the numbers are given first, followed by the\noperators. The expression (1 * 2)+(3 * 4) would be 1 2 * 3 4 * + in this notation.\n\nA calculator for this notation can be represented well with the help of a stack.\nThe notation is processed from left to right.\nIf a number is processed, it is put on the stack.\nIf an operator is encountered, then the uppermost two numbers are taken from the stack,\nthe operator is executed and the result is put back on the stack.\nAfter the calculation, the result is the only number on the stack.\n\nIn this task you are asked to implement such a calculator in a method.\nIt should be able to process the operators plus (+), minus (-), times (*)\nand division (/, rounded down). You will receive a stack with the following\nknown methods, which you have to use in your implementation:\n\n* emptystack()\n* head()\n* push(int i)\n* pop()\n\nThe method receives as input a list of strings in which the\nnumbers and operators are already separated (e.g..: input =\n[\"1\", \"2\", \"*\", \"3\", \"4\", \"*\", \"+\"]). Strings can be converted with \"int(myString)\".\nYou will also get a stack, which you should use.\nThe method should return the correct result as an integer.\n\nYou can assume that the input is a correct formula.\n",
    "skeleton": "def Calculator(inputarray, stack):\n    return 0",
    "reference_solution": "# This implementation assumes input is a correct formula\ndef Calculator(inputarray, stack):\n    for i in inputarray:\n        try:\n            stack.push({\n                \"+\": lambda x, y: y+x,\n                \"-\": lambda x, y: y-x,\n                \"*\": lambda x, y: y*x,\n                \"/\": lambda x, y: y/x,}[i](stack.pop(), stack.pop()))\n        except KeyError:\n            stack.push(int(i))\n    return stack.pop()"
  },
  "19_20-3-1-python": {
    "title_eng": "List Sorting (Python)",
    "description_eng": "Implement any search algorithm from the lecture\nthat sorts the given list.\n\nThe list has the following operations, which get as input indexes of the\nlist elements:\n\n* Swap(int x, int y) <- Swaps the items at position x and y.\n\n* Larger(int x, int y) <- Returns true if the item at\nposition x is greater than the item at position y\n\n* Smaller(int x, int y) <- Returns true if the item at\nposition y is greater than the element at position x\n\n* Equal(int x, int y) <- Returns true if the element at\nposition y is equal to the element at position x\n\n* Length() <- Returns the length of the list\n",
    "skeleton": "def listSorter(listToSort: ListToSort) -> ListToSort:\n    pass",
    "reference_solution": "def listSorter(listToSort: ListToSort) -> ListToSort:\n    \"\"\"\n    This is an implimentation of bubble sort\n    \"\"\"\n    changed = True\n    while changed:\n        changed = False\n        for i in range(1, listToSort.Length()):\n            if listToSort.Larger(i-1, i):\n                listToSort.Swap(i-1, i)\n                changed = True\n    return listToSort"
  },
  "19_20-4-1-python": {
    "title_eng": "Search trees: Insertion (Python)",
    "description_eng": "These tasks will be about search trees. Our search trees are built from\n\"nodes\", analogous to the lecture. A node looks like this:\n\nclass Node:\n\u00a0* key\n\u00a0* left\n\u00a0* right\n\u00a0* parent\n\nIn the lecture you have already seen an algorithm for searching in a search tree.\n\nYou are to implement different methods for the search trees.\nFor this task, implement a method \"insert\" that inserts a\n\"Node\" into the search tree and returns the new search tree.\nThe nodes can be reused as desired. The function\nis passed the root of the search tree and the new node.",
    "skeleton": "# Node in parameter represents root of tree\ndef insert(root, insert):\n    return None",
    "reference_solution": "# Node in parameter represents root of tree\ndef insert(root: Node, insert: Node):\n    x = root\n    y = None  # saves Node.parent\n    while x is not None:\n        y = x\n        if insert.key < x.key:\n            x = x.left\n        else:\n            x = x.right;\n\n    insert.parent = y\n    if y is None:\n        return insert\n    elif insert.key < y.key:\n        y.left = insert\n    else:\n        y.right = insert;\n\n    return root"
  },
  "19_20-4-2-python": {
    "title_eng": "Search trees: Removal (Python)",
    "description_eng": "These tasks will again be about search trees. Reminder:\nOur search trees are built from \"nodes\", analogous to the lecture.\nA node looks like this:\n\nclass Node:\n\u00a0* key\n\u00a0* left\n\u00a0* right\n\u00a0* Parent\n\nFor this task, implement a method \"delete\" which deletes a\n\"Node\" in the search tree and returns the new search tree. Use the\nthe method from the lecture slides, i.e. the one with \"TREE-MINIMUM\".\nThe nodes can be reused as desired. The function gets the root\nof the search tree and the node to be deleted.\n",
    "skeleton": "# Node in parameter represents root of tree\ndef delete(root, delete):\n    return None",
    "reference_solution": "# Helper function\ndef tree_minimum(n):\n    while n.left is not None:\n        n = n.left\n    return n\n# Node in parameter represents root of tree\ndef delete(root: Node, delete: Node):\n    y = None  # y: node to delete (after swap)\n    if delete.left is None or delete.right is None:\n        y = delete\n    else:\n        y = tree_minimum(delete.right)\n    x = None  # non-null child of y\n    if y.left is not None:\n        x = y.left\n    else:\n        x = y.right\n    # now delete y\n    if x is not None:\n        x.parent = y.parent\n    if y.parent is None:\n        root = x\n    else:\n        if y is y.parent.left:\n            y.parent.left = x\n        else:\n            y.parent.right = x\n    # Copy data\n    if y is not delete:\n        delete.key = y.key\n    # y should have no reference and should be deleted by the python gc\n    return root"
  },
  "19_20-5-1-python": {
    "title_eng": "Graphs: BFS (Python)",
    "description_eng": "This task is about the implementation of graphs and very\nsimple graph algorithms. In Java we implement graphs with the\nthe help of arrays. We look at graphs with unweighted edges.\nTo represent a graph in Java, we give all nodes a number (starting with 0),\nwhich corresponds to the index of the adjacency list in the list. Example:\n\ngraph = [\n    [1, 2],\n    [0],\n    [1]\n]\n\nEach of these edges can now be considered as directed, going out\nfrom the node with the index number to the node with the corresponding\nnumber (see image for a graphical visualization).\n\nNow we want to implement some simple algorithms for the graphs,\nstarting with breadth-first search. How this\nalgorithm works can be found in the lecture, see also Cormen et\nal, chap. 22. The inputs are assumed to be unweighted, directed graphs,\nso it is not always the case that for each edge there is also a back edge\nrunning in the opposite direction.\n\nThe outputs shall contain the nodes of the graph in the order\nas they are processed by the corresponding search.\nThe nodes are to be traversed in the order in which they are arranged in the adjacency list.",
    "skeleton": "def bfs(graph, start):\n    return []",
    "reference_solution": "def bfs(graph, start):\n    visited, queue = list(), [start]\n    while queue:\n        next = queue.pop(0)\n        if next not in visited:\n            visited.append(next)\n            for vertex in graph[next]:\n                if vertex not in visited:\n                    queue.append(vertex)\n    return visited"
  },
  "19_20-5-2-python": {
    "title_eng": "Graphs: DFS (Python)",
    "description_eng": "As a second algorithm - analogous to the first task - a depth\ndepth-first search is to be implemented.\n\nHere, too, the nodes are to be visited in the order in which they appear in the adjacency list.",
    "skeleton": "def dfs(graph, start):\n    return []",
    "reference_solution": "def dfs(graph, start):\n    visited, queue = list(), [start]\n    while queue:\n        next = queue.pop()\n        if next not in visited:\n            visited.append(next)\n            for vertex in reversed(graph[next]): # Need to reverse list in order to visit vertex in correct order\n                if vertex not in visited:\n                    queue.append(vertex)\n    return visited"
  },
  "19_20-6-1-python": {
    "title_eng": "Dynamic Programming: Edit Distance (Python)",
    "description_eng": "In this task the edit distance of two given strings is implemented.\nThis is defined as the minimum number of insert, delete and replace operations\nof single characters to convert the one string into the other.\nImportant: The implementation must NOT use recursive calls.",
    "skeleton": "def editDistance(a, b):\n    return 0",
    "reference_solution": "def editDistance(a, b):\n    \"\"\"This function calculates and returns the edit distance\n    beween tow given strings. this strings are given by the\n    parameters a and b. In the implementation the recursive\n    definition is implemented iterativly\"\"\"\n    \n    m = len(a)\n    n = len(b)\n\n    edDis = [0] * (m+1)\n    for i in range(m+1):\n        edDis[i] = [0] * (n+1)\n\n    for i in range(m+1):\n        edDis[i][0] = i\n        \n    for i in range(n+1):\n        edDis[0][i] = i\n\n    for i in range(1,m+1):\n        for j in range(1,n+1):\n            if a[i-1]==b[j-1]:\n                edDis[i][j] = edDis[i-1][j-1]\n            else:\n                edDis[i][j] = 1 + min(edDis[i][j-1],\n                                      edDis[i-1][j],\n                                      edDis[i-1][j-1])\n\n    return edDis[len(a)][len(b)]"
  },
  "19_20-6-2-python": {
    "title_eng": "Dynamic Programming: Knapsack (Python)",
    "description_eng": "The Knapsack problem is an optimization problem. Which items\nfrom an existing selection should be packed into a limited\nbackpack(Knapsack) in order to maximize the value to be transported?\nThis problem is in generall NP-complete and therefore\nprobably not efficiently solvable. Assuming that the\nvolumes of the objects are integers, we can find an algorithm\nthat solves this problem using dynamic programming. We are looking for\nthe implementation of an algorithm, which for a given list of objects and a\nlist of items and a maximum backpack volume outputs the value\nthat can be transported at most. The list of items\nconsists of two lists, one contains the volumes and one the values.\nvalues. So the input ([0.5, 0.3], [2, 5], 3 ) gives two items,\nthe first with volume 2 and value 0.5, the second with volume 5 and value 0.3.\nThe last value indicates the volume of the Knapsack, in this case\nthe correct output of the algorithm would be 0.5 because only\nthe 1st item fits into the backpack at all. With a larger volume\nof 7, the correct output would be 0.8. It is important to note that the solution\nis NOT 1.5, so it is not possible to use the same object more than once.",
    "skeleton": "def knapSack(value, volume, capacity):\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    # TODO\n\n    return 0",
    "reference_solution": "def knapSack(value, volume, capacity):\n    \"\"\"This function calculates and returns the max\n    value in knapsack with the capacity \"capacity\" wich is filled\n    with stuff of volume \"volume\" and the value \"value\".\"\"\"\n\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    n = len(value)\n\n    Result = [0] * (n+1)\n    for i in range(n+1):\n        Result[i] = [0] * (capacity + 1)\n\n    for i in range(n+1):\n        for j in range(capacity + 1):\n            Result[i][j] = 0\n\n    for i in range(n-1,-1,-1):\n        for j in range(1, capacity + 1):\n            if volume[i] <= j:\n                Result[i][j] = max(value[i] + Result[i + 1][j - volume[i]],\n                                   Result[i+1][j])\n            else:\n                Result[i][j] = Result[i+1][j]\n\n    return Result[0][capacity]"
  }
}
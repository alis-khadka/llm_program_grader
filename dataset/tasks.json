{
  "19_20-1-1-python": {
    "title_eng": "LCM -- Least Common Multiple (Python)",
    "description_eng": "Similar to the already known \"Greatest Common Divisor\" (GCD),\nthe Least Common Multiple (LCM) is also used in elementary mathematical\napplications, for example in the multiplication of heterogeneous fractions. This\nhas applications ranging from the adaptation of cooking recipes to other\nportion quantities to the calculation of planetary orbits.\n\nThe LCM is defined as follows:\n$lcm(n_1, n_2)=\\frac{n_1 \\cdot n_2}{gcd(n_1,n_2)}$.\n\nImplement a function that calculates the LCM of two given values.\nIt may be based on the GCD implementation from the lecture.\n\nNote: The use of \"import\" is not allowed.",
    "skeleton_code": "def LCM(a, b):\n    pass",
    "reference_solution": "def GCD(a, b):\n    if a < b:\n        a, b = b, a\n    r = a % b\n    if r is 0:\n        return b\n    else:\n        return GCD(r, b)\n        \ndef LCM(a, b):\n    return a * b / GCD(a, b)"
  },
  "19_20-2-1-python": {
    "title_eng": "Queue (Python)",
    "description_eng": "Implement a class \"Queue\" that works like a queue (as described in the\nthe lecture). The class should have at least the\nmethods isEmpty(), head(), enqueue(x) and dequeue(). The\nqueue does not need to hold more than 100 elements.\n\nNote 1: In the Java test, the stack is expected to store \"strings\".\nSince Python is dynamically typed, this does not apply.\n\nNote 2: It is not allowed to use \"import\"!",
    "skeleton_code": "class Queue:\n    \"\"\"Klasse, die eine selbstgebaute Queue darstellt.\n    \"\"\"\n\n    def isEmpty(self):\n        \"\"\"Prueft, ob die Queue leer ist.\n        :return: True, wenn die Queue leer ist;\n            False, sonst\n        \"\"\"\n        pass\n\n    def head(self):\n        \"\"\"Gibt den Wert des ersten Elements in der Queue\n            zurueck.\n        :return: Den Wert des ersten Elementes in der Queue\n        \"\"\"\n        pass\n\n    def enqueue(self, x):\n        \"\"\"Haengt ein Element an die Queue an.\n        :param x: Anzuhaengendes Element\n        \"\"\"\n        pass\n\n    def dequeue(self):\n        \"\"\"Entfernt das erste Element aus der Queue\n        :return: Erstes Element\n        \"\"\"\n        pass",
    "reference_solution": "class Queue:\n    \"\"\"Klasse, die eine selbstgebaute Queue darstellt.\n    \"\"\"\n    def __init__(self):\n        self.lst = []\n\n    def isEmpty(self) -> bool:\n        \"\"\"Prueft, ob die Queue leer ist.\n        :return: True, wenn die Queue leer ist;\n            False, sonst\n        \"\"\"\n        return len(self.lst) == 0\n\n    def head(self):\n        \"\"\"Gibt den Wert des ersten Elements in der Queue\n            zurueck.\n        :return: Den Wert des ersten Elementes in der Queue\n        \"\"\"\n        if not self.isEmpty():\n            return self.lst[0]\n        else:\n            return None\n\n    def enqueue(self, x):\n        \"\"\"Haengt ein Element an die Queue an.\n        :param x: Anzuhaengendes Element\n        \"\"\"\n        self.lst.append(x)\n\n    def dequeue(self):\n        \"\"\"Entfernt das erste Element aus der Queue\n        :return: Erstes Element\n        \"\"\"\n        if not self.isEmpty():\n            returnvalue = self.lst[0]\n            for i in range(len(self.lst) - 1):\n                self.lst[i] = self.lst[i+1]\n            del self.lst[-1]\n            return returnvalue\n        else:\n            raise IndexError"
  },
  "19_20-2-2-python": {
    "title_eng": "Stack (Python)",
    "description_eng": "The Reverse Polish Notation / Postfix Notation is a special notation for\nfor mathematical expressions, where the numbers are given first, followed by the\noperators. The expression (1 * 2)+(3 * 4) would be 1 2 * 3 4 * + in this notation.\n\nA calculator for this notation can be represented well with the help of a stack.\nThe notation is processed from left to right.\nIf a number is processed, it is put on the stack.\nIf an operator is encountered, then the uppermost two numbers are taken from the stack,\nthe operator is executed and the result is put back on the stack.\nAfter the calculation, the result is the only number on the stack.\n\nIn this task you are asked to implement such a calculator in a method.\nIt should be able to process the operators plus (+), minus (-), times (*)\nand division (/, rounded down). You will receive a stack with the following\nknown methods, which you have to use in your implementation:\n\n* emptystack()\n* head()\n* push(int i)\n* pop()\n\nThe method receives as input a list of strings in which the\nnumbers and operators are already separated (e.g..: input =\n[\"1\", \"2\", \"*\", \"3\", \"4\", \"*\", \"+\"]). Strings can be converted with \"int(myString)\".\nYou will also get a stack, which you should use.\nThe method should return the correct result as an integer.\n\nYou can assume that the input is a correct formula.\n",
    "skeleton_code": "def Calculator(inputarray, stack):\n    return 0",
    "reference_solution": "# This implementation assumes input is a correct formula\ndef Calculator(inputarray, stack):\n    for i in inputarray:\n        try:\n            stack.push({\n                \"+\": lambda x, y: y+x,\n                \"-\": lambda x, y: y-x,\n                \"*\": lambda x, y: y*x,\n                \"/\": lambda x, y: y/x,}[i](stack.pop(), stack.pop()))\n        except KeyError:\n            stack.push(int(i))\n    return stack.pop()"
  },
  "19_20-3-1-python": {
    "title_eng": "List Sorting (Python)",
    "description_eng": "Implement any search algorithm from the lecture\nthat sorts the given list.\n\nThe list has the following operations, which get as input indexes of the\nlist elements:\n\n* Swap(int x, int y) <- Swaps the items at position x and y.\n\n* Larger(int x, int y) <- Returns true if the item at\nposition x is greater than the item at position y\n\n* Smaller(int x, int y) <- Returns true if the item at\nposition y is greater than the element at position x\n\n* Equal(int x, int y) <- Returns true if the element at\nposition y is equal to the element at position x\n\n* Length() <- Returns the length of the list\n",
    "skeleton_code": "def listSorter(listToSort: ListToSort) -> ListToSort:\n    pass",
    "reference_solution": "def listSorter(listToSort: ListToSort) -> ListToSort:\n    \"\"\"\n    This is an implimentation of bubble sort\n    \"\"\"\n    changed = True\n    while changed:\n        changed = False\n        for i in range(1, listToSort.Length()):\n            if listToSort.Larger(i-1, i):\n                listToSort.Swap(i-1, i)\n                changed = True\n    return listToSort"
  },
  "19_20-4-1-python": {
    "title_eng": "Search trees: Insertion (Python)",
    "description_eng": "These tasks will be about search trees. Our search trees are built from\n\"nodes\", analogous to the lecture. A node looks like this:\n\nclass Node:\n\u00a0* key\n\u00a0* left\n\u00a0* right\n\u00a0* parent\n\nIn the lecture you have already seen an algorithm for searching in a search tree.\n\nYou are to implement different methods for the search trees.\nFor this task, implement a method \"insert\" that inserts a\n\"Node\" into the search tree and returns the new search tree.\nThe nodes can be reused as desired. The function\nis passed the root of the search tree and the new node.",
    "skeleton_code": "# Node in parameter represents root of tree\ndef insert(root, insert):\n    return None",
    "reference_solution": "# Node in parameter represents root of tree\ndef insert(root: Node, insert: Node):\n    x = root\n    y = None  # saves Node.parent\n    while x is not None:\n        y = x\n        if insert.key < x.key:\n            x = x.left\n        else:\n            x = x.right;\n\n    insert.parent = y\n    if y is None:\n        return insert\n    elif insert.key < y.key:\n        y.left = insert\n    else:\n        y.right = insert;\n\n    return root"
  },
  "19_20-4-2-python": {
    "title_eng": "Search trees: Removal (Python)",
    "description_eng": "These tasks will again be about search trees. Reminder:\nOur search trees are built from \"nodes\", analogous to the lecture.\nA node looks like this:\n\nclass Node:\n\u00a0* key\n\u00a0* left\n\u00a0* right\n\u00a0* Parent\n\nFor this task, implement a method \"delete\" which deletes a\n\"Node\" in the search tree and returns the new search tree. Use the\nthe method from the lecture slides, i.e. the one with \"TREE-MINIMUM\".\nThe nodes can be reused as desired. The function gets the root\nof the search tree and the node to be deleted.\n",
    "skeleton_code": "# Node in parameter represents root of tree\ndef delete(root, delete):\n    return None",
    "reference_solution": "# Helper function\ndef tree_minimum(n):\n    while n.left is not None:\n        n = n.left\n    return n\n# Node in parameter represents root of tree\ndef delete(root: Node, delete: Node):\n    y = None  # y: node to delete (after swap)\n    if delete.left is None or delete.right is None:\n        y = delete\n    else:\n        y = tree_minimum(delete.right)\n    x = None  # non-null child of y\n    if y.left is not None:\n        x = y.left\n    else:\n        x = y.right\n    # now delete y\n    if x is not None:\n        x.parent = y.parent\n    if y.parent is None:\n        root = x\n    else:\n        if y is y.parent.left:\n            y.parent.left = x\n        else:\n            y.parent.right = x\n    # Copy data\n    if y is not delete:\n        delete.key = y.key\n    # y should have no reference and should be deleted by the python gc\n    return root"
  },
  "19_20-5-1-python": {
    "title_eng": "Graphs: BFS (Python)",
    "description_eng": "This task is about the implementation of graphs and very\nsimple graph algorithms. In Java we implement graphs with the\nthe help of arrays. We look at graphs with unweighted edges.\nTo represent a graph in Java, we give all nodes a number (starting with 0),\nwhich corresponds to the index of the adjacency list in the list. Example:\n\ngraph = [\n    [1, 2],\n    [0],\n    [1]\n]\n\nEach of these edges can now be considered as directed, going out\nfrom the node with the index number to the node with the corresponding\nnumber (see image for a graphical visualization).\n\nNow we want to implement some simple algorithms for the graphs,\nstarting with breadth-first search. How this\nalgorithm works can be found in the lecture, see also Cormen et\nal, chap. 22. The inputs are assumed to be unweighted, directed graphs,\nso it is not always the case that for each edge there is also a back edge\nrunning in the opposite direction.\n\nThe outputs shall contain the nodes of the graph in the order\nas they are processed by the corresponding search.\nThe nodes are to be traversed in the order in which they are arranged in the adjacency list.",
    "skeleton_code": "def bfs(graph, start):\n    return []",
    "reference_solution": "def bfs(graph, start):\n    visited, queue = list(), [start]\n    while queue:\n        next = queue.pop(0)\n        if next not in visited:\n            visited.append(next)\n            for vertex in graph[next]:\n                if vertex not in visited:\n                    queue.append(vertex)\n    return visited"
  },
  "19_20-5-2-python": {
    "title_eng": "Graphs: DFS (Python)",
    "description_eng": "As a second algorithm - analogous to the first task - a depth\ndepth-first search is to be implemented.\n\nHere, too, the nodes are to be visited in the order in which they appear in the adjacency list.",
    "skeleton_code": "def dfs(graph, start):\n    return []",
    "reference_solution": "def dfs(graph, start):\n    visited, queue = list(), [start]\n    while queue:\n        next = queue.pop()\n        if next not in visited:\n            visited.append(next)\n            for vertex in reversed(graph[next]): # Need to reverse list in order to visit vertex in correct order\n                if vertex not in visited:\n                    queue.append(vertex)\n    return visited"
  },
  "19_20-6-1-python": {
    "title_eng": "Dynamic Programming: Edit Distance (Python)",
    "description_eng": "In this task the edit distance of two given strings is implemented.\nThis is defined as the minimum number of insert, delete and replace operations\nof single characters to convert the one string into the other.\nImportant: The implementation must NOT use recursive calls.",
    "skeleton_code": "def editDistance(a, b):\n    return 0",
    "reference_solution": "def editDistance(a, b):\n    \"\"\"This function calculates and returns the edit distance\n    beween tow given strings. this strings are given by the\n    parameters a and b. In the implementation the recursive\n    definition is implemented iterativly\"\"\"\n    \n    m = len(a)\n    n = len(b)\n\n    edDis = [0] * (m+1)\n    for i in range(m+1):\n        edDis[i] = [0] * (n+1)\n\n    for i in range(m+1):\n        edDis[i][0] = i\n        \n    for i in range(n+1):\n        edDis[0][i] = i\n\n    for i in range(1,m+1):\n        for j in range(1,n+1):\n            if a[i-1]==b[j-1]:\n                edDis[i][j] = edDis[i-1][j-1]\n            else:\n                edDis[i][j] = 1 + min(edDis[i][j-1],\n                                      edDis[i-1][j],\n                                      edDis[i-1][j-1])\n\n    return edDis[len(a)][len(b)]"
  },
  "19_20-6-2-python": {
    "title_eng": "Dynamic Programming: Knapsack (Python)",
    "description_eng": "The Knapsack problem is an optimization problem. Which items\nfrom an existing selection should be packed into a limited\nbackpack(Knapsack) in order to maximize the value to be transported?\nThis problem is in generall NP-complete and therefore\nprobably not efficiently solvable. Assuming that the\nvolumes of the objects are integers, we can find an algorithm\nthat solves this problem using dynamic programming. We are looking for\nthe implementation of an algorithm, which for a given list of objects and a\nlist of items and a maximum backpack volume outputs the value\nthat can be transported at most. The list of items\nconsists of two lists, one contains the volumes and one the values.\nvalues. So the input ([0.5, 0.3], [2, 5], 3 ) gives two items,\nthe first with volume 2 and value 0.5, the second with volume 5 and value 0.3.\nThe last value indicates the volume of the Knapsack, in this case\nthe correct output of the algorithm would be 0.5 because only\nthe 1st item fits into the backpack at all. With a larger volume\nof 7, the correct output would be 0.8. It is important to note that the solution\nis NOT 1.5, so it is not possible to use the same object more than once.",
    "skeleton_code": "def knapSack(value, volume, capacity):\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    # TODO\n\n    return 0",
    "reference_solution": "def knapSack(value, volume, capacity):\n    \"\"\"This function calculates and returns the max\n    value in knapsack with the capacity \"capacity\" wich is filled\n    with stuff of volume \"volume\" and the value \"value\".\"\"\"\n\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    n = len(value)\n\n    Result = [0] * (n+1)\n    for i in range(n+1):\n        Result[i] = [0] * (capacity + 1)\n\n    for i in range(n+1):\n        for j in range(capacity + 1):\n            Result[i][j] = 0\n\n    for i in range(n-1,-1,-1):\n        for j in range(1, capacity + 1):\n            if volume[i] <= j:\n                Result[i][j] = max(value[i] + Result[i + 1][j - volume[i]],\n                                   Result[i+1][j])\n            else:\n                Result[i][j] = Result[i+1][j]\n\n    return Result[0][capacity]"
  },
  "20_21-1-1-python": {
    "title_eng": "Exponentiation by squaring (Python)",
    "description_eng": "Input: $a,b,c \\in \\mathbb{N}_0  \\land 1 \\leq a \\leq 100 \\land 0 \\leq b \\leq 10^9 \\land 1 \\leq c \\leq 10^{10}$\n\nOutput: $a^b \\; mod \\; c$\n\nLet $a^b \\; mod \\; c$ be calculated in the function expo(a,b,c). Make sure\nthat your algorithm has a run time of $O(log \\; b + log \\; c)$.\nYour solution must not contain the string \"import\" and \"**\" as a\nsubstring. For easier debugging, you can divide your result\nin each calculation step by modulo $c$. For example (The example\ncan also be found commented out in the answer field):\n\ndef add(a,b,c,d,e):\n    res = (a+b) % 10000007\n    res = (res+c) % 10000007\n    res = (res+d) % 10000007\n    res = (res+e) % 10000007\n    return (res+1000) % 10000007\n\nHint:\n\nUse \"//\" (without the quotes) to perform integer division in\nPython and to avoid floats.\n\nIf $b$ is even, then:\n\n$a^b = (a^{\\frac{b}{2}})^2 = a^{\\frac{b}{2}} \\cdot a^{\\frac{b}{2}}$\n\nIf $b$ is odd, then:\n\n$a^b = a^{b-1} \\cdot a$",
    "skeleton_code": "def expo(a,b,c):\n    pass\n\n\n'''\ndef addiere(a,b,c,d,e):\n\n    res = (a+b) % 1000000007\n\n    res = (res+c) % 1000000007\n\n    res = (res+d) % 1000000007\n\n    res = (res+e) % 1000000007\n\n    return (res+1000) % 1000000007\n'''",
    "reference_solution": "def expo(a,b,c):\n    if b == 0:\n        return 1 % c\n    elif b % 2:\n        return (a * expo(a,b-1,c)) % c\n    else:\n        a = expo(a,b // 2,c) % c\n        return (a*a) % c"
  },
  "20_21-1-2-python": {
    "title_eng": "Sorting (Python)",
    "description_eng": "Input: An array $A = [a_1, a_2,...,a_n]$ with $2 \\leq n \\leq 10^6$\nand $\\forall 1\\leq i \\leq n: -10^6 \\leq a_i \\leq 10^6$\n\nOutput:  Array A sorted in ascending order: $A = [a_1, a_2,...,a_n]$,\nwhere $\\forall 1 \\leq i \\leq j \\leq n: \\; a[i] \\leq a[j]$\n\nImplement a sorting procedure in the function \"solution\", which takes\nas argument an array \"A\".  Your procedure should\neither have a worst-case run time of $O(n \\; log \\; n)$ or an\naverage-case run time of $O(n \\; log \\; n)$ (this should be guaranteed by\nrandomization). Your solution must not contain the string\n\"sort\" and \"numpy\" as substring. Importing the random\nlibrary is explicitly allowed!\n\nHint:\n\nMake absolutely sure that you randomize your algorithm using the\nPython Random Library. You can ignore this hint\nif your implementation has a worst-case runtime of $O(n \\; log \\; n)$.",
    "skeleton_code": "def solution(A):\n    pass",
    "reference_solution": "import random as rand\ndef randPartition(A,l,r):\n    i = rand.randint(l,r)\n    temp = A[i]\n    A[i] = A[r]\n    A[r] = temp\n    return partition(A,l,r)\n\ndef partition(A,l,r):\n    x = A[r]\n    i = l-1\n    for j in range(l,r):\n        if A[j] <= x:\n            i = i + 1\n            temp = A[i]\n            A[i] = A[j]\n            A[j] = temp\n    temp = A[i+1]\n    A[i+1] = A[r]\n    A[r] = temp\n    return i+1\n\ndef quick(A,l,r):\n    if l < r:\n        p = randPartition(A,l,r)\n        quick(A,l,p-1)\n        quick(A,p+1,r)\n\n\ndef solution(A):\n    quick(A,0,len(A)-1)\n    return A"
  },
  "20_21-2-1-python": {
    "title_eng": "Logistics at the North Pole (Python)",
    "description_eng": "Input: Two arrays $A = [a_1, a_2,...,a_n], B = [b_1, b_2, ..., b_m]$\nmit  $1 \\leq m, n  \\leq 4 \\cdot 10^6$\nand $\\forall 1\\leq i  \\leq n:  0 \\leq a_i,b_i  \\leq 10^6$.\nMoreover, $\\max(A) \\leq |B| - 1$\n\nOutput:  A binary string $s$ of length $m$ , where the $i$-th digit is\nis defined as follows:\n\n$s[i] = \\begin{cases} 1, &\\text{if } |A|_i \\leq B[i] \\ 0, &\\text{if } |A|_i > B[i] \\end{cases}$\n\nwhere $|A|_i$ describes how often the number $i$ occurs in the array $A$.\n\nTimelimit: 5 CPU seconds\n\nIt is Christmas and Santa Claus has little time left: He must\ncome up with a system to deliver all presents in time.\nFor this he uses the following system: First, all the cuddly\ntoys are delivered, then all books, and so on. The category of the\n$i-$th gift is $A[i]$. Unfortunately Santa's sleigh does not\nhave an infinitely large capacity: For objects of the\ncategory $i$, Santa's sleigh has a maximum capacity of $B[ i]$.\nNow he would like to know if it is possible to deliver all objects of a\ncategory in one run. For this he wants\nyou to generate a string with the following properties:\nthe $i$-th digit is a one if it is possible to deliver all objects of the\ncategory $i$ in one pass and $0$ if this is not possible.\nAs a reminder, Santa Claus can deliver all objects of the\ncategory $i$ in one pass if $|A|_i \\leq B[i]$ holds.\nSince Santa does not have much time left, your algorithm must have\na run time of $O(n + m)$.\n\nHint:\n\n(1) The substring \"import\", \"eval\",\"sort\", \"sol_calc\" or \"getattr\" must\nnot appear in your solution. \n\n(2) Unlike defined in Cormen, arrays and strings of length\n$n$ start at 0 and end at $n-1$.",
    "skeleton_code": "def calc(A,B):\n    pass",
    "reference_solution": "def calc(A, B):\n    C = []\n    for i in range(10**6 + 1):\n        C.append(0)\n    for a in A:\n        C[a] = C[a] + 1\n    sol = \"\"\n    for i in range(len(B)):\n        if C[i] <= B[i]:\n            sol += \"1\"\n        else:\n            sol += \"0\"\n    return sol"
  },
  "20_21-3-1-python": {
    "title_eng": "Knapsack (Python) (revised version 2020/21)",
    "description_eng": "",
    "skeleton_code": "def knapSack(value, volume, capacity):\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    # TODO\n\n    return 0",
    "reference_solution": "def knapSack(value, volume, capacity):\n    \"\"\"This function calculates and returns the max\n    value in knapsack with the capacity \"capacity\" wich is filled\n    with stuff of volume \"volume\" and the value \"value\".\"\"\"\n\n    assert len(value) == len(volume)\n\n    for x in volume:\n        assert x == round(x)\n\n    n = len(value)\n\n    Result = [0] * (n+1)\n    for i in range(n+1):\n        Result[i] = [0] * (capacity + 1)\n\n    for i in range(n+1):\n        for j in range(capacity + 1):\n            Result[i][j] = 0\n\n    for i in range(n-1,-1,-1):\n        for j in range(1, capacity + 1):\n            if volume[i] <= j:\n                Result[i][j] = max(value[i] + Result[i + 1][j - volume[i]],\n                                   Result[i+1][j])\n            else:\n                Result[i][j] = Result[i+1][j]\n\n    return Result[0][capacity]"
  },
  "20_21-3-2-python": {
    "title_eng": "Longest path DAG (Python)",
    "description_eng": "Input: A natural number $1 \\leq N \\leq 2500$, which indicates how many\nvertices the graph $G$ has, and a two-dimensional array $A$ of size\nsize $1 \\leq M \\leq 10^6$ of integers\n$A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]$ which is\nencodes the set of edges of $G$.  If $[a,b] \\in A$, then there is a\ndirected edge from the vertex $a$ to the vertex $b$. You may assume\nthat there are no directed cycles in $G$. For example: Let $N = 3$\nand $A = [[1,2],[2,3]]$ then the following graph is obtained:\n\n[]\n\nOutput: The length of the longest directed path in $G$.\nYour algorithm has to compute the solution in $O(N+M)$.\n\nTime limit: 1 CPU second\n\nHint:\n\n(1) The libraries java.util.Arrays, java.util.ArrayList, java.lang.Math\nare already imported automatically.\n\n(2) If you have difficulties with this task: Ignore\nthe runtime restrictions and first implement a naive \nrecursive solution. Then use dynamic programming\n(memoization) to achieve the desired runtime.\n\n(3) Some test cases have been hidden and are not displayed to\nprevent hardcoding of the solutions.",
    "skeleton_code": "def calc(N,A):\n    pass",
    "reference_solution": "def dfs(node, graph, memo):\n    if len(graph[node]) == 0:\n        return 0\n    elif memo[node] != -1:\n        return memo[node]\n    else:\n        sol = 0\n        for child in graph[node]:\n            sol = max(sol, dfs(child, graph, memo) + 1)\n        memo[node] = sol\n        return memo[node]\n\n\ndef calc(N, A):\n    graph = [[] for _ in range(N + 1)]\n    memo = [-1] * (N + 1)\n    graph[0] = [x for x in range(1, N + 1)]\n    for edge in A:\n        start, end = edge\n        graph[start].append(end)\n    return dfs(0, graph, memo) - 1"
  },
  "21_22-1-1-python": {
    "title_eng": "Divide and Conquer Recurrence [Python]",
    "description_eng": "Input: $n_0 \\in \\mathbb{N}_0: \\; 0 \\leq n_0 \\leq 10^{9}$ \n\nOutput: $a_{n_0} \\; mod \\; 10^9+7$ with\n$a_{n+1}=2 a_{n}+1 \\; \\; n \\in \\mathbb{N}_0, a_{0}=0$\n\nCalculate in $O(\\: log \\: n)$ the output for any input\nin the function \"def calc(n):\" that takes only an integer as a parameter.\nFor the implementation you must not use the keyword\n\"import\", \"**\", \"eval\" , \"checkCalc\", \"globals\", \"pow\" or \"expo\".\n\nFor easier debugging, you can divide your result in each calculation step by modulo $10^9+7$. For example:\n\ndef calc(a,b,c):\n\n    res = (a+b) % 10000007\n\n    res = (res+c) % 10000007\n\n    return (res+1000) % 10000007\n\nHints:\n\n1. Find a closed form for the recurrence.\n\n2. Use \"//\" (without the quotation marks) to perform integer division in\nPython and to avoid floats.\n\n3. If $b$ is even, then:\n\n$a^b = (a^{\\frac{b}{2}})^2 = a^{\\frac{b}{2}} \\cdot a^{\\frac{b}{2}}$\n\nIf $b$ is odd, then:\n\n$a^b = a^{b-1} \\cdot a$  \n",
    "skeleton_code": "def calc(n):\n    pass",
    "reference_solution": "def calc(n):\n    a = 2; b = n; c = 1000000007\n    return expo(a,b,c) - 1\ndef expo(a,b,c):\n    if b == 0:\n        return 1 % c\n    elif b % 2:\n        return (a * expo(a,b-1,c)) % c\n    else:\n        a = expo(a,b // 2,c) % c\n        return (a*a) % c"
  },
  "21_22-1-2-python": {
    "title_eng": "Divide and Conquer Function [Python]",
    "description_eng": "Let $N \\in \\mathbb{N} \\land N \\leq 10^{18}$ and\n$f_N:\\mathbb{N}_0 \\mapsto \\{0,1\\}, \\; n \\mapsto \\begin{cases}1, & \\text { if } n \\geq N \\ 0, & \\text { if } n < N \\end{cases}$\na binary function, where $N$ is unknown. The goal of the task is to calculate $N$ \nin $O(log \\: n)$.\n\nInput: A binary function $f_N$, where $N$ is unknown.\n\nOutput: $N$.\n\nThe function $f_N$ is available as argument in the\nimplementation.  For the implementation you must not use the keyword\n\"import\" , \"globals\" or \"eval\". Calculate the output\nin $O(log \\: n)$ in the function \"calc(f)\".\n\nHints:\n\n1. Analyze the monotonicity of the function.\n\n2. Let $x \\in \\mathbb{N}$ with $f_N(x) = 0$. What do we know for all\nvalues $y \\in \\mathbb{N}, y < x$? Now let $f_N(x) = 1$. What do we know\nfor all values $z \\in \\mathbb{N}, x < z$?\n",
    "skeleton_code": "def calc(f):\n    pass",
    "reference_solution": "def calc(f):\n    l = 0\n    r = 10**(18)\n    while 0 <= l <= r:\n        m = ((r + l) // 2)\n        #print(m)\n        if f(m):\n            r = m - 1\n        else:\n            l = m + 1\n    if f(m):\n        return m\n    else:\n        return m + 1"
  },
  "21_22-2-1-python": {
    "title_eng": "Logistics at the North Pole (Python)",
    "description_eng": "It's Christmas and Santa Claus has little time left: he must\nto come up with a system to deliver all the presents on time.\nTo do this, he uses the following system: first, all the cuddly\ntoys are delivered, then all the books, and so on. The category of the\n$i-$th gift is $A[i]$. Unfortunately the sleigh of\nSanta Claus does not have an infinitely large capacity: For objects of the\ncategory $i$, Santa's sleigh has a maximum capacity of $B[ i]$.\nNow he would like to know if it is possible to deliver all the\nobjects of a category in one run. For this he wants\nyou to generate a string with the following properties:\nthe $i$-th digit is a one, if it is possible to deliver\nall objects of the category $i$ in one pass and $0$,\nif this is not possible. As a reminder, Santa Claus can\ndeliver all objects of category $i$ in one pass,\nif $|A|_i \\leq B[i]$ holds. Since Santa does not have much time left\nyour algorithm must have a runtime of $O(n + m)$.\n\nInput: Two arrays $A = [a_1, a_2,...,a_n], B = [b_1, b_2, ..., b_m]$\nwith $1 \\leq m, n \\leq 4 \\cdot 10^6$\nand $\\forall 1\\leq i \\leq n: 0 \\leq a_i,b_i \\leq 10^6$. Furthermore\nit holds: $\\max(A) \\leq |B| - 1$\n\nOutput:  A binary string $s$ of length $m$ , where the $i$-th digit is\nis defined as follows:\n\n$s[i] = \\begin{cases} 1, &\\text{when } |A|_i \\leq B[i] \\ 0, &\\text{when } |A|_i > B[i] \\end{cases}$\n\nwhere $|A|_i$ describes how many times the number $i$ occurs in the array $A$.\n\nTimelimit: 5 CPU seconds\n\nHint:\n\n(1) The substring \"import\", \"eval\", \"sort\", \"sol_calc\", or \"getattr\"\nmust not appear in your solution. \n\n(2) Unlike defined in Cormen, arrays and strings of length\n$n$ start at 0 and end at $n-1$ .\n",
    "skeleton_code": "def calc(A,B):\n    pass",
    "reference_solution": "def calc(A, B):\n    C = []\n    for i in range(10**6 + 1):\n        C.append(0)\n    for a in A:\n        C[a] = C[a] + 1\n    sol = \"\"\n    for i in range(len(B)):\n        if C[i] <= B[i]:\n            sol += \"1\"\n        else:\n            sol += \"0\"\n    return sol"
  },
  "21_22-2-2-python": {
    "title_eng": "Transporting Goods (Python)",
    "description_eng": "In a large warehouse, one robot is responsible for transporting\ngoods from warehouse X to warehouse Y. The robot worked $n$ days.\nOn the $i-$th (for $0\\leq i\\leq n-1$) day, the robot moved $x_i$ goods\nfrom the first warehouse to the second warehouse. These values are stored in a\nlist of length $n$ of non-negative integers:\n$A = [x_0,...,x_{n-1}]$. Now we want to process a list of\nqueries $B = [(l_1,r_1),...,(l_n,r_n)]$. \n\nFor this one would like to know how many goods the robot has tranported between the days\n$l_i$ and $r_i$ with $0\\leq l_i \\leq r_i \\leq n-1$ for\n$1\\leq i\\leq n$. Here $[l_i,r_i]$ forms a closed\ninterval. For example, for $A = [x_0,x_1] = [4,5]$ and queries\n$B =[(l_1,r_1),(l_2,r_2)] = [(1,1),(0,1)]$ we get\n$[\\sum_{i=l_1}^{r_1}x_i,\\sum_{i=l_2}^{r_2}x_i] = [\\sum_{i=1}^{1}x_i,\\sum_{i=0}^{1}x_i] = [5, 4 + 5]$.\n\nSo for each query, we want to return a list of the following\nform:\n\n$[\\sum_{i=l_1}^{r_1}x_i,...,\\sum_{i=l_n}^{r_n}x_i]$. This calculation\nshall be done in $O(n)$.\n\nThe string \"check_calc\" or \"eval\" must not appear in your solution.\n\nInput: a list of length $n$ of non-negative integers:\n$A = [x_0,...,x_{n-1}]$ and a list of two-tuples of length\n$O(n)$ $B = [(l_1,r_1),...,(l_n,r_n)]$ with $0\\leq l_i \\leq r_i \\leq n-1$\nfor $1\\leq i\\leq n$).\n\nOutput: A list of length $n$ of non-negative integers:\n\n$[\\sum_{i=l_1}^{r_1}x_i,...,\\sum_{i=l_n}^{r_n}x_i]$ computed in $O(n)$.\n\nHere the string \"check_calc\" or \"eval\" must not appear in your solution\n\nNote: Let $l_j \\geq 1$. Then: \n\n$\\sum_{i=l_j}^{r_j}x_i= \\sum_{k=0}^{r_j}x_k - \\sum_{k=0}^{l_j - 1}x_k$ ",
    "skeleton_code": "def calc(a,b):\n    return []",
    "reference_solution": "def calc(a,b):\n    n = len(a)\n    c = [0] * n\n    d = [0] * n\n    c[0] = a[0]\n    for i in range(1,n):\n        c[i] += a[i] + c[i-1]\n    for i in range(n):\n        if b[i][0] - 1 >= 0:\n            d[i] = c[b[i][1]]- c[b[i][0] - 1]\n        else:\n            d[i] = c[b[i][1]]\n    return d"
  },
  "21_22-3-1-python": {
    "title_eng": "Billboard (Python)",
    "description_eng": "(This task is a slightly modified old exam task from the\nWS 2020/21)\n\nA company obtains permission to place billboards on one side of a road.\nAlong the $n \\in \\mathbb{N}$ kilometers long road, there are $n+1$ suitable\nlocations at intervals of exactly one kilometer. For the location at kilometer\n$i \\in\\{0,1, \\ldots, n\\}$ advertisers are willing to pay an amount $w_i$\nwith $0 < w_{i} < 10^9$ to the company. However, the road traffic regulation states\nthat there must be at least two kilometers between every two billboards.\nSo if the company places a billboard at kilometer $i$, then at kilometer $i-1$ and $i+1$\nno billboard may be placed.\n\nHelp the company determine a selection of locations that will\nmaximizes the total profit from renting the sites.\n\nInput: an array $W$ of size $n+1$ for a\n$n \\in \\mathbb{N} \\land 1 \\leq n \\leq 1000$.\n\nOutput: The maximum profit that can be obtained from the billboards.\n\nThe output must be calculated in $O(n)$.\n",
    "skeleton_code": "def opt(W):\n    pass",
    "reference_solution": "def opt(W):\n    n = len(W) - 1\n    memo = [-1] * (n + 1)\n    return opt_helper(n, W, memo)\n\n\ndef opt_helper(n, W, memo):\n    if n == 0:\n        return W[0]\n    if n == 1:\n        return max(W[0], W[1])\n    if memo[n] != -1:\n        return memo[n]\n    else:\n        memo[n] = max(W[n] + opt_helper(n - 2, W, memo), opt_helper(n - 1, W, memo))\n        return memo[n]"
  },
  "21_22-3-2-python": {
    "title_eng": "Longest path DAG (Python)",
    "description_eng": "The goal of this task is to find the longest path in the dag (directed acyclic\ngraph) in $O(N+M)$. \n\nInput: A natural number $1 \\leq N \\leq 2500$, which indicates how many\nnodes the graph $G$ has. A two dimensional array $A$ of the\nsize $1 \\leq M \\leq 10^6$ of integers\n$A = [[a^{1}_1,a^{2}_1],[a^{1}_2,a^{2}_2],...,[a^{1}_M,a^{2}_M]]$, which\nencodes the node and edge set of $G$.  If $[a,b] \\in A$, then\nthere is a directed edge from the node$a$ to the node $b$. You\nmay assume that there are no directed cycles in $G$. An\nexample: let $N = 3$ and the edges $A = [[1,2],[2,3]]$ then the result is\nthe following graph:\n\n[]\n\nOutput: The length of the longest directed path in $G$.\nYour algorithm must compute the solution in $O(N+M)$.\n\nTime limit: 4 CPU seconds ($O(N+M)$ ).\n\nHint:\n\n(1) The substring \"import\", \"eval\", \"sol_calc\", or \"getattr\" must not\nappear in your solution. \n\n(2) If you have difficulties with this task: Ignore\nthe runtime restrictions and first implement a naive \nrecursive solution. Then use dynamic programming\n(memoization) to achieve the desired runtime.\n\n(3) Some test cases have been hidden and are not displayed to \nprevent hardcoding of the solutions.\n(4) If you have difficulties with the task, read the following\npages from Cormen (Introduction to algorithms third edition) pp.\n384-389 (from the subitem \"overlapping subproblems\") and/or\nhttps://en.wikipedia.org/wiki/Overlapping_subproblems.",
    "skeleton_code": "def calc(N,A):\n    pass",
    "reference_solution": "def dfs(node, graph, memo):\n    if len(graph[node]) == 0:\n        return 0\n    elif memo[node] != -1:\n        return memo[node]\n    else:\n        sol = 0\n        for child in graph[node]:\n            sol = max(sol, dfs(child, graph, memo) + 1)\n        memo[node] = sol\n        return memo[node]\n\n\ndef calc(N, A):\n    graph = [[] for _ in range(N + 1)]\n    memo = [-1] * (N + 1)\n    graph[0] = [x for x in range(1, N + 1)]\n    for edge in A:\n        start, end = edge\n        graph[start].append(end)\n    return dfs(0, graph, memo) - 1"
  }
}